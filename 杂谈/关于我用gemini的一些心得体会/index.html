<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>y@7q | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">y@7q</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
    
        <div class="post-main-title">
            关于我用gemini的一些心得体会
        </div>
        <div class="post-meta">
            2025-08-01
        </div>
        <div class="post-md">
            <h1 id="关于我用gemini的一些心得体会"><a href="#关于我用gemini的一些心得体会" class="headerlink" title="关于我用gemini的一些心得体会"></a>关于我用gemini的一些心得体会</h1><p>​		最近刚刚白嫖了Gemini的15个月学生会员，于是开始用这个号称目前top1的大模型，并且在使用过程中，有了一些自己的使用心得。</p>
<span id="more"></span>

<h2 id="用Gemini进行文档总结"><a href="#用Gemini进行文档总结" class="headerlink" title="用Gemini进行文档总结"></a>用Gemini进行文档总结</h2><p>​		在碰到需要阅读的外文文档的时候，如果是公网资源，可以直接交给AI链接，然后让他总结并娓娓道来详细讲给你听。</p>
<p>​		这里我自认为是一个技巧，可以让他讲解的更易于理解。</p>
<p><img src="https://raw.githubusercontent.com/yatq21/Pictures/main/Blog/study/image-20250625211529087.png" alt="image-20250625211529087"></p>
<p>​		这是21年CS61A的关于记忆化的一节课课件，我在听教授讲的时候听的很迷糊（当然没有说教授讲的不好，只是我没适应 ），于是直接把把链接给Gemini让他帮我总结：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>web.archive.org<span class="regexp">/web/</span><span class="number">20210506190608</span><span class="regexp">/https:/</span><span class="regexp">/cs61a.org/</span>assets<span class="regexp">/slides/</span><span class="number">21</span>-Memoization_4pp.pdf</span><br><span class="line"></span><br><span class="line">帮我总结并娓娓道来</span><br></pre></td></tr></table></figure>

<p>但我发现他总结的很精简，我需要的是那种能学到东西的文章，于是改了一下prompt：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请你给出代码示例，像写一个完整的博客文档那样详细的讲解这节课的所有内容</span><br></pre></td></tr></table></figure>

<p>然后我就得到了我想要的：</p>
<blockquote>
<p>好的，没问题！让我们像撰写一篇详细的博客文章一样，深入探讨“记忆化（Memoization）”的奥秘。</p>
<hr>
<h2 id="博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”"><a href="#博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”" class="headerlink" title="博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”"></a>博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”</h2><p>你好，我是你的AI助手 Gemini。在编程的世界里，我们总在追求两件事：<strong>正确性</strong>和<strong>效率</strong>。今天，我们将探讨一种能够极大提升代码效率，特别是递归函数效率的强大技术——<strong>记忆化（Memoization）</strong>。</p>
<p>想象一下，你让计算机解决一个问题，它却像一个健忘的学徒，一遍又一遍地计算着早已知道答案的子问题。这不仅浪费了宝贵的计算资源，也让你的程序运行得像蜗牛一样慢。记忆化，就是赋予我们程序“记忆”能力的魔法。</p>
<h3 id="一、问题的根源：重复的计算"><a href="#一、问题的根源：重复的计算" class="headerlink" title="一、问题的根源：重复的计算"></a>一、问题的根源：重复的计算</h3><p>让我们从一个经典得不能再经典的例子开始：<strong>斐波那契数列（Fibonacci Sequence）</strong>。</p>
<p>它的定义很简单：</p>
<ul>
<li><code>fib(0) = 0</code></li>
<li><code>fib(1) = 1</code></li>
<li><code>fib(n) = fib(n-1) + fib(n-2)</code> (当 n &gt; 1 时)</li>
</ul>
<p>用 Python 来实现这个定义，最直观的方式就是写一个简单的递归函数：</p>
<p><strong>版本一：朴素的递归实现</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算斐波那契数列的第 n 项（朴素递归法）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让我们来测试一下</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib(5) = <span class="subst">&#123;fib(<span class="number">5</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib(10) = <span class="subst">&#123;fib(<span class="number">10</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># print(f&quot;fib(40) = &#123;fib(40)&#125;&quot;) # 尝试运行这行，你会等到天荒地老...</span></span><br></pre></td></tr></table></figure>

<p>这段代码看起来简洁优美，完美地翻译了数学定义。但它的性能如何呢？</p>
<p>让我们来追踪一下 <code>fib(5)</code> 的计算过程，你会看到一棵像这样的“调用树”：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                   <span class="function"><span class="title">fib</span>(<span class="number">5</span>)</span></span><br><span class="line">                /         \</span><br><span class="line">            <span class="function"><span class="title">fib</span>(<span class="number">4</span>)         <span class="title">fib</span>(<span class="number">3</span>)</span></span><br><span class="line">           /      \       /      \</span><br><span class="line">        <span class="function"><span class="title">fib</span>(<span class="number">3</span>)   <span class="title">fib</span>(<span class="number">2</span>)   <span class="title">fib</span>(<span class="number">2</span>)   <span class="title">fib</span>(<span class="number">1</span>)</span></span><br><span class="line">       /      \   /    \   /    \</span><br><span class="line">    <span class="function"><span class="title">fib</span>(<span class="number">2</span>) <span class="title">fib</span>(<span class="number">1</span>) <span class="title">fib</span>(<span class="number">1</span>) <span class="title">fib</span>(<span class="number">0</span>) <span class="title">fib</span>(<span class="number">1</span>) <span class="title">fib</span>(<span class="number">0</span>)</span></span><br><span class="line">   /      \</span><br><span class="line"><span class="function"><span class="title">fib</span>(<span class="number">1</span>)   <span class="title">fib</span>(<span class="number">0</span>)</span></span><br></pre></td></tr></table></figure>

<p>发现了问题所在吗？</p>
<ul>
<li><code>fib(3)</code> 被计算了 <strong>2</strong> 次。</li>
<li><code>fib(2)</code> 被计算了 <strong>3</strong> 次。</li>
<li><code>fib(1)</code> 被计算了 <strong>5</strong> 次。</li>
</ul>
<p>仅仅是计算 <code>fib(5)</code>，就有如此多的冗余。当 <code>n</code> 增长到 40 或 50，重复计算的次数将呈指数级爆炸式增长（时间复杂度为 O(2^n)），足以让现代计算机陷入漫长的等待。</p>
<p>这就是我们需要“记忆化”来拯救世界的时刻。</p>
<h3 id="二、核心思想：记住你算过的"><a href="#二、核心思想：记住你算过的" class="headerlink" title="二、核心思想：记住你算过的"></a>二、核心思想：记住你算过的</h3><p><strong>记忆化（Memoization）</strong>的核心思想异常简单：</p>
<blockquote>
<p><strong>如果一个计算你已经执行过，就把结果存起来。下次再遇到同样的计算，直接拿出存好的结果，不要再算一遍。</strong></p>
</blockquote>
<p>这本质上是一种“用空间换时间”的策略。我们开辟一小块内存空间（我们的“记忆”），用来缓存计算结果，从而避免了大量耗时的重复计算。</p>
<p>我们如何为上面的 <code>fib</code> 函数植入“记忆”呢？通常，我们会使用一个<strong>字典（dictionary）</strong>或<strong>哈希表（hash map）</strong>来作为我们的缓存（cache）。</p>
<p><strong>版本二：带有记忆化的递归实现</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个缓存字典，用来存储已经计算过的结果</span></span><br><span class="line">memo_cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_memo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算斐波那G契数列的第 n 项（带记忆化的递归）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 在计算之前，先检查“记忆”里有没有</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo_cache:</span><br><span class="line">        <span class="keyword">return</span> memo_cache[n] <span class="comment"># 如果有，直接返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 如果没有，再进行计算（和之前的逻辑一样）</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        result = n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = fib_memo(n-<span class="number">1</span>) + fib_memo(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 在返回结果之前，把这次的结果存入“记忆”</span></span><br><span class="line">    memo_cache[n] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让我们来测试一下性能的飞跃</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_memo(40) = <span class="subst">&#123;fib_memo(<span class="number">40</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_memo(50) = <span class="subst">&#123;fib_memo(<span class="number">50</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 这一次，结果几乎是瞬间出现的！</span></span><br></pre></td></tr></table></figure>

<p>让我们再次分析 <code>fib_memo(5)</code> 的调用过程：</p>
<ol>
<li><code>fib_memo(5)</code>：缓存里没有，计算 <code>fib_memo(4) + fib_memo(3)</code>。</li>
<li><code>fib_memo(4)</code>：缓存里没有，计算 <code>fib_memo(3) + fib_memo(2)</code>。</li>
<li><code>fib_memo(3)</code>：缓存里没有，计算 <code>fib_memo(2) + fib_memo(1)</code>。</li>
<li><code>fib_memo(2)</code>：缓存里没有，计算 <code>fib_memo(1) + fib_memo(0)</code>。</li>
<li><code>fib_memo(1)</code>：返回 1，并存入缓存 <code>&#123;1: 1&#125;</code>。</li>
<li><code>fib_memo(0)</code>：返回 0，并存入缓存 <code>&#123;0: 0, 1: 1&#125;</code>。</li>
<li><code>fib_memo(2)</code> 完成计算 (1+0&#x3D;1)，存入缓存 <code>&#123;0:0, 1:1, 2:1&#125;</code>。</li>
<li><code>fib_memo(3)</code> 需要 <code>fib_memo(1)</code>，<strong>直接从缓存读取</strong>，计算 (1+1&#x3D;2)，存入缓存 <code>&#123;..., 3:2&#125;</code>。</li>
<li><code>fib_memo(4)</code> 需要 <code>fib_memo(2)</code>，<strong>直接从缓存读取</strong>，计算 (2+1&#x3D;3)，存入缓存 <code>&#123;..., 4:3&#125;</code>。</li>
<li><code>fib_memo(5)</code> 需要 <code>fib_memo(3)</code>，<strong>直接从缓存读取</strong>，计算 (3+2&#x3D;5)，存入缓存 <code>&#123;..., 5:5&#125;</code>。</li>
</ol>
<p>看！<code>fib_memo(3)</code> 和 <code>fib_memo(2)</code> 现在只被完整地计算了一次。所有后续的调用都直接从缓存中获取了结果。通过这种方式，我们将时间复杂度从 O(2^n) 奇迹般地降到了 **O(n)**，因为从 0 到 n 的每个斐波那契数都只被计算了一次。</p>
<h3 id="三、更优雅的实现：Python装饰器"><a href="#三、更优雅的实现：Python装饰器" class="headerlink" title="三、更优雅的实现：Python装饰器"></a>三、更优雅的实现：Python装饰器</h3><p>虽然上面的方法很有效，但它把缓存逻辑和业务逻辑（斐波那契计算）混在了一起。如果我有很多个函数都需要记忆化，难道要给每个函数都写一套缓存逻辑吗？</p>
<p>当然不！这正是 Python 中<strong>装饰器（Decorator）</strong>大显身手的时刻。装饰器允许我们在不修改函数代码本身的情况下，为函数添加额外的功能。</p>
<p>我们可以编写一个通用的 <code>memoize</code> 装饰器。</p>
<p><strong>版本三：使用装饰器实现记忆化</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">memoize</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个通用的记忆化装饰器&quot;&quot;&quot;</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="comment"># 注意：这里我们使用 *args 作为键，使其能处理多个参数的函数</span></span><br><span class="line">        <span class="comment"># 但要确保参数是可哈希的（比如数字、字符串、元组）</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_decorator</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;应用了记忆化装饰器的斐波那契函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib_decorator(n-<span class="number">1</span>) + fib_decorator(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下，同样飞快！</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_decorator(50) = <span class="subst">&#123;fib_decorator(<span class="number">50</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_decorator(100) = <span class="subst">&#123;fib_decorator(<span class="number">100</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>@memoize</code> 语法糖，完全等同于 <code>fib_decorator = memoize(fib_decorator)</code>。</p>
<p>这种方式的好处是：</p>
<ol>
<li><strong>代码整洁</strong>：<code>fib_decorator</code> 函数内部只关心核心的计算逻辑。</li>
<li><strong>高度复用</strong>：你可以把 <code>@memoize</code> 这个装饰器应用到任何其他需要记忆化的、符合条件的函数上。</li>
</ol>
<h3 id="四、什么时候应该使用记忆化？"><a href="#四、什么时候应该使用记忆化？" class="headerlink" title="四、什么时候应该使用记忆化？"></a>四、什么时候应该使用记忆化？</h3><p>记忆化虽好，但并非万能。它在以下场景中最为有效：</p>
<ol>
<li><strong>函数是“纯”的（Pure Function）</strong>：这是最重要的前提。纯函数意味着对于相同的输入，永远返回相同的输出，并且没有可观察的副作用（比如修改全局变量、打印日志等）。斐波那契函数就是典型的纯函数。</li>
<li><strong>存在大量重叠子问题（Overlapping Subproblems）</strong>：就像我们的斐波那契例子，递归过程中反复求解相同的子问题。如果一个问题可以被分解成子问题，但子问题之间毫无关联，那么记忆化就派不上用场。</li>
<li><strong>计算成本较高</strong>：如果一个函数本身的计算非常快，那么为它增加缓存和查找的开销可能得不偿失。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天，我们通过斐波那契数列的例子，深入了解了<strong>记忆化</strong>这一强大的性能优化技术。</p>
<ul>
<li><strong>核心痛点</strong>：递归调用中存在大量的重复计算，导致指数级的时间复杂度。</li>
<li><strong>解决方案</strong>：使用缓存（如字典）存储计算结果，避免重复劳动，实现“用空间换时间”。</li>
<li><strong>最佳实践</strong>：将记忆化逻辑封装成一个通用的装饰器，以保持业务代码的纯粹和整洁。</li>
</ul>
<p>记忆化是<strong>动态规划（Dynamic Programming）</strong>思想的重要组成部分，是每个程序员都应该掌握的基本功。希望通过这篇详细的讲解，你已经彻底理解了它的原理和应用。现在，去检查一下你的代码，看看有没有哪个“健忘”的函数正在等待你赋予它“记忆”吧！</p>
</blockquote>
<p>​		<strong>读这种文章的感觉就和读大佬写的博客文一样酣畅淋漓！</strong>然后我又让他解释了一下其中装饰器的作用，还是这种模式的回复：</p>
<blockquote>
<p>当然可以！很高兴你对这个话题有如此浓厚的兴趣。装饰器是 Python 中一个非常强大且优雅的特性，一旦你理解了它，就会发现它无处不在。</p>
<p>让我们一步一步，把“<code>@memoize</code> 等同于 <code>fib_decorator = memoize(fib_decorator)</code>”这块硬骨头彻底啃下来。</p>
<h3 id="第-1-步：理解-Python-的核心前提——函数是“一等公民”"><a href="#第-1-步：理解-Python-的核心前提——函数是“一等公民”" class="headerlink" title="第 1 步：理解 Python 的核心前提——函数是“一等公民”"></a>第 1 步：理解 Python 的核心前提——函数是“一等公民”</h3><p>在 Python 中，函数（function）和我们常见的数字（<code>123</code>）、字符串（<code>&quot;hello&quot;</code>）、列表（<code>[1, 2, 3]</code>）一样，是一种<strong>对象</strong>。这意味着你可以像对待任何其他数据一样对待它。</p>
<p>这具体体现在三个方面：</p>
<ol>
<li><p><strong>可以被赋值给一个变量</strong></p>
<p>Python</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数 say_hello 赋值给变量 greet</span></span><br><span class="line">greet = say_hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在调用 greet 和调用 say_hello 的效果完全一样</span></span><br><span class="line">greet()       <span class="comment"># 输出: Hello!</span></span><br><span class="line">say_hello()   <span class="comment"># 输出: Hello!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以作为参数传递给另一个函数</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_operation</span>(<span class="params">func, x, y</span>):</span><br><span class="line">    <span class="comment"># 调用传进来的函数 func</span></span><br><span class="line">    <span class="keyword">return</span> func(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 add 函数作为参数传进去</span></span><br><span class="line">result1 = simple_operation(add, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Result of addition: <span class="subst">&#123;result1&#125;</span>&quot;</span>) <span class="comment"># 输出: 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 subtract 函数作为参数传进去</span></span><br><span class="line">result2 = simple_operation(subtract, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Result of subtraction: <span class="subst">&#123;result2&#125;</span>&quot;</span>) <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>simple_operation</code> 就是一个<strong>高阶函数（Higher-Order Function）</strong>，因为它接受了另一个函数作为参数。</p>
</li>
<li><p><strong>可以作为另一个函数的返回值</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_greeter</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="comment"># 定义一个内部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeter</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="comment"># 返回这个内部函数</span></span><br><span class="line">    <span class="keyword">return</span> greeter</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 调用 get_greeter，它返回了 greeter 函数</span></span><br><span class="line">greet_bob = get_greeter(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">greet_alice = get_greeter(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># greet_bob 现在是一个函数了！</span></span><br><span class="line">greet_bob()   <span class="comment"># 输出: Hello, Bob!</span></span><br><span class="line">greet_alice() <span class="comment"># 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>理解了“函数是一等公民”这个核心概念，我们就为理解装饰器铺平了道路。</p>
<h3 id="第-2-步：手动实现一个装饰器"><a href="#第-2-步：手动实现一个装饰器" class="headerlink" title="第 2 步：手动实现一个装饰器"></a>第 2 步：手动实现一个装饰器</h3><p>装饰器本质上就是一个高阶函数，它<strong>接收一个函数作为输入，并返回一个新的函数作为输出</strong>。这个新的函数通常会在执行原始函数的前后，添加一些额外的功能。</p>
<p>让我们来手动实现这个过程，不使用 <code>@</code> 语法。</p>
<p>假设我们有一个简单的函数：</p>
<p>Python</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">ordinary_function</span>():</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="string">&quot;正在执行核心业务...&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>现在，我们想在不修改 <code>ordinary_function</code> 源码的情况下，在它执行前后打印日志。我们可以写一个“装饰函数”：</p>
<p>Python</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def logging_decorator(original_func):</span><br><span class="line">    # original_func 就是我们想装饰的函数，比如 ordinary_function</span><br><span class="line"></span><br><span class="line">    # <span class="number">1.</span> 定义一个新的“包装”函数</span><br><span class="line">    def <span class="keyword">wrapper</span>():</span><br><span class="line">        print(f&quot;【日志】函数 &#x27;&#123;original_func.__name__&#125;&#x27; 即将执行...&quot;)</span><br><span class="line">        </span><br><span class="line">        # <span class="number">2.</span> 在包装函数内部，调用原始函数</span><br><span class="line">        original_func()</span><br><span class="line">        </span><br><span class="line">        print(f&quot;【日志】函数 &#x27;&#123;original_func.__name__&#125;&#x27; 执行完毕。&quot;)</span><br><span class="line"></span><br><span class="line">    # <span class="number">3.</span> 返回这个包装好的新函数</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">wrapper</span></span><br></pre></td></tr></table></figure>

<p>现在，最关键的一步来了。我们如何使用 <code>logging_decorator</code> 来“装饰” <code>ordinary_function</code> 呢？</p>
<p>Python</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将我们的普通函数“喂”给装饰器，然后用返回的新函数，覆盖掉原来的函数名</span><br><span class="line">ordinary_function = logging_decorator(ordinary_function)</span><br><span class="line"></span><br><span class="line"># 现在，当你调用 ordinary_function 时，你实际上调用的是 <span class="keyword">wrapper</span> 函数！</span><br><span class="line">ordinary_function()</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【日志】函数 <span class="string">&#x27;ordinary_function&#x27;</span> 即将执行<span class="params">...</span></span><br><span class="line">正在执行核心业务<span class="params">...</span></span><br><span class="line">【日志】函数 <span class="string">&#x27;ordinary_function&#x27;</span> 执行完毕。</span><br></pre></td></tr></table></figure>

<p>看到了吗？<code>ordinary_function = logging_decorator(ordinary_function)</code> 这行代码，就是装饰器模式的核心。它用一个功能更强的“包装版”函数，替换了原始的函数。</p>
<h3 id="第-3-步：揭开-的神秘面纱"><a href="#第-3-步：揭开-的神秘面纱" class="headerlink" title="第 3 步：揭开 @ 的神秘面纱"></a>第 3 步：揭开 <code>@</code> 的神秘面纱</h3><p>Python 的设计者们发现，上面这种 <code>func = decorator(func)</code> 的写法非常常用，所以他们创造了一个更简洁、更具可读性的语法来做<strong>完全相同</strong>的事情，这个语法就是 <code>@</code>，我们称之为“语法糖（Syntactic Sugar）”。</p>
<p>所以，下面这两段代码是<strong>完全等价的</strong>：</p>
<p><strong>写法一：手动赋值</strong></p>
<p>Python</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">ordinary_function</span>():</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="string">&quot;正在执行核心业务...&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">ordinary_function</span> = <span class="function"><span class="title">logging_decorator</span>(<span class="variable">ordinary_function</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>写法二：使用 <code>@</code> 语法糖</strong></p>
<p>Python</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@logging_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ordinary_function</span>():</span><br><span class="line">    print(<span class="string">&quot;正在执行核心业务...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当 Python 解释器读到 <code>@logging_decorator</code> 时，它会先定义 <code>ordinary_function</code>，然后<strong>自动地</strong>在内部执行 <code>ordinary_function = logging_decorator(ordinary_function)</code> 这个操作。</p>
<h3 id="第-4-步：回到-memoize"><a href="#第-4-步：回到-memoize" class="headerlink" title="第 4 步：回到 @memoize"></a>第 4 步：回到 <code>@memoize</code></h3><p>现在，我们带着全新的理解，回头看 <code>memoize</code> 的例子：</p>
<p>Python</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">memoize</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function">    cache</span> = &#123;&#125;</span><br><span class="line">    <span class="function">def <span class="title">wrapper</span>(<span class="params">*<span class="keyword">args</span></span>):</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="keyword">args</span> <span class="keyword">not</span> <span class="keyword">in</span> cache:</span></span><br><span class="line"><span class="function">            cache[<span class="keyword">args</span>]</span> = func(*<span class="keyword">args</span>) <span class="meta"># 这里调用的是原始的 fib_decorator</span></span><br><span class="line">        <span class="keyword">return</span> cache[<span class="keyword">args</span>]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">@memoize</span><br><span class="line"><span class="function">def <span class="title">fib_decorator</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> n &lt;</span>= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="function">n</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">fib_decorator</span>(<span class="params">n<span class="number">-1</span></span>) + <span class="title">fib_decorator</span>(<span class="params">n<span class="number">-2</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>这段代码在 Python 解释器眼里的执行流程是：</p>
<ol>
<li>解释器看到了 <code>def fib_decorator...</code>，于是它在内存中创建了一个斐波那契计算函数，我们称之为**原始 <code>fib_decorator</code>**。</li>
<li>接着，解释器看到了它头顶的 <code>@memoize</code>。</li>
<li>它立刻执行 <code>memoize(原始_fib_decorator)</code>。</li>
<li><code>memoize</code> 函数返回了 <code>wrapper</code> 函数。（这个 <code>wrapper</code> 函数内部通过闭包 <code>func</code> 记住了**原始 <code>fib_decorator</code>**，并且还创建了一个私有的 <code>cache</code> 字典）。</li>
<li>解释器用返回的 <code>wrapper</code> 函数，覆盖了 <code>fib_decorator</code> 这个名字。</li>
</ol>
<p>所以，在这之后，当你的代码调用 fib_decorator(5) 时，你实际上调用的是 wrapper(5)。</p>
<p>wrapper 函数会：</p>
<ul>
<li>检查 <code>(5,)</code> 这个参数元组是否在它的 <code>cache</code> 里。</li>
<li>如果不在，它就会调用它所“记住”的<strong>原始 <code>fib_decorator</code></strong> 函数（<code>func(5)</code>），并将计算结果存入 <code>cache</code>。</li>
<li>最后，返回 <code>cache</code> 中的值。</li>
</ul>
<p>有趣的是，<code>wrapper</code> 内部的递归调用 <code>fib_decorator(n-1)</code> 和 <code>fib_decorator(n-2)</code>，因为 <code>fib_decorator</code> 这个名字已经被替换了，所以它们调用的也是 <code>wrapper</code> 函数，而不是原始函数。这恰好就是我们想要的——确保每一次递归调用都能利用上缓存机制！</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>@decorator</code> 就是一个语法糖，它让你能够以一种声明式的方式，将一个函数（<code>decorator</code>）应用到另一个函数（被装饰的函数）上。</p>
<p>其背后的完整逻辑链是：</p>
<p>@decorator -&gt; func &#x3D; decorator(func) -&gt; 函数作为一等公民（可以被传递和返回）</p>
<p>希望这个从底层原理到语法糖的逐层剖析，能让你彻底明白装饰器的运作方式！</p>
</blockquote>

        </div>

    

</div>
                <div class="footer">
    <span>Copyright © 2022 y@7q</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這李設計</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>