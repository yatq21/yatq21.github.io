<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="关于我用gemini的一些心得体会​		最近刚刚白嫖了Gemini的15个月学生会员，于是开始用这个号称目前top1的大模型，并且在使用过程中，有了一些自己的使用心得。">
<meta property="og:type" content="article">
<meta property="og:title" content="关于我用gemini的一些心得体会">
<meta property="og:url" content="http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/index.html">
<meta property="og:site_name" content="y@7q">
<meta property="og:description" content="关于我用gemini的一些心得体会​		最近刚刚白嫖了Gemini的15个月学生会员，于是开始用这个号称目前top1的大模型，并且在使用过程中，有了一些自己的使用心得。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yatq21/Pictures/main/Blog/study/image-20250625211529087.png">
<meta property="article:published_time" content="2025-07-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-01T03:42:00.573Z">
<meta property="article:author" content="y@7q">
<meta property="article:tag" content="gemini">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yatq21/Pictures/main/Blog/study/image-20250625211529087.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>关于我用gemini的一些心得体会</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/CTF%E8%B5%9B%E4%BA%8B%E6%80%BB%E7%BB%93/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982024%E5%A4%8D%E7%8E%B0/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/web%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/CScourse/CS61B%20Essentials/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&text=关于我用gemini的一些心得体会"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&is_video=false&description=关于我用gemini的一些心得体会"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于我用gemini的一些心得体会&body=Check out this article: http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&name=关于我用gemini的一些心得体会&description=&lt;h1 id=&#34;关于我用gemini的一些心得体会&#34;&gt;&lt;a href=&#34;#关于我用gemini的一些心得体会&#34; class=&#34;headerlink&#34; title=&#34;关于我用gemini的一些心得体会&#34;&gt;&lt;/a&gt;关于我用gemini的一些心得体会&lt;/h1&gt;&lt;p&gt;​		最近刚刚白嫖了Gemini的15个月学生会员，于是开始用这个号称目前top1的大模型，并且在使用过程中，有了一些自己的使用心得。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&t=关于我用gemini的一些心得体会"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">关于我用gemini的一些心得体会</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8Gemini%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">用Gemini进行文档总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2z%E6%96%87%E7%AB%A0%EF%BC%9A%E7%94%A8%E2%80%9C%E8%AE%B0%E5%BF%86%E2%80%9D%E7%BB%99%E4%BB%A3%E7%A0%81%E5%8A%A0%E9%80%9F%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E2%80%9C%E8%AE%B0%E5%BF%86%E5%8C%96%EF%BC%88Memoization%EF%BC%89%E2%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E9%87%8D%E5%A4%8D%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、问题的根源：重复的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E8%AE%B0%E4%BD%8F%E4%BD%A0%E7%AE%97%E8%BF%87%E7%9A%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、核心思想：记住你算过的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">三、更优雅的实现：Python装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">四、什么时候应该使用记忆化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E6%AD%A5%EF%BC%9A%E7%90%86%E8%A7%A3-Python-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%89%8D%E6%8F%90%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D"><span class="toc-number">1.2.6.</span> <span class="toc-text">第 1 步：理解 Python 的核心前提——函数是“一等公民”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E6%AD%A5%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">第 2 步：手动实现一个装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E6%AD%A5%EF%BC%9A%E6%8F%AD%E5%BC%80-%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="toc-number">1.2.8.</span> <span class="toc-text">第 3 步：揭开 @ 的神秘面纱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E6%AD%A5%EF%BC%9A%E5%9B%9E%E5%88%B0-memoize"><span class="toc-number">1.2.9.</span> <span class="toc-text">第 4 步：回到 @memoize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.2.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        关于我用gemini的一些心得体会
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">y@7q</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-31T16:00:00.000Z" class="dt-published" itemprop="datePublished">2025-08-01</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/gemini/" rel="tag">gemini</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="关于我用gemini的一些心得体会"><a href="#关于我用gemini的一些心得体会" class="headerlink" title="关于我用gemini的一些心得体会"></a>关于我用gemini的一些心得体会</h1><p>​		最近刚刚白嫖了Gemini的15个月学生会员，于是开始用这个号称目前top1的大模型，并且在使用过程中，有了一些自己的使用心得。</p>
<span id="more"></span>

<h2 id="用Gemini进行文档总结"><a href="#用Gemini进行文档总结" class="headerlink" title="用Gemini进行文档总结"></a>用Gemini进行文档总结</h2><p>​		在碰到需要阅读的外文文档的时候，如果是公网资源，可以直接交给AI链接，然后让他总结并娓娓道来详细讲给你听。</p>
<p>​		这里我自认为是一个技巧，可以让他讲解的更易于理解。</p>
<p><img src="https://raw.githubusercontent.com/yatq21/Pictures/main/Blog/study/image-20250625211529087.png" alt="image-20250625211529087"></p>
<p>​		这是21年CS61A的关于记忆化的一节课课件，我在听教授讲的时候听的很迷糊（当然没有说教授讲的不好，只是我没适应 ），于是直接把把链接给Gemini让他帮我总结：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>web.archive.org<span class="regexp">/web/</span><span class="number">20210506190608</span><span class="regexp">/https:/</span><span class="regexp">/cs61a.org/</span>assets<span class="regexp">/slides/</span><span class="number">21</span>-Memoization_4pp.pdf</span><br><span class="line"></span><br><span class="line">帮我总结并娓娓道来</span><br></pre></td></tr></table></figure>

<p>但我发现他总结的很精简，我需要的是那种能学到东西的文章，于是改了一下prompt：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请你给出代码示例，像写一个完整的博客文档那样详细的讲解这节课的所有内容</span><br></pre></td></tr></table></figure>

<p>然后我就得到了我想要的：</p>
<blockquote>
<p>好的，没问题！让我们像撰写一篇详细的博客文章一样，深入探讨“记忆化（Memoization）”的奥秘。</p>
<hr>
<h2 id="博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”"><a href="#博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”" class="headerlink" title="博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”"></a>博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”</h2><p>你好，我是你的AI助手 Gemini。在编程的世界里，我们总在追求两件事：<strong>正确性</strong>和<strong>效率</strong>。今天，我们将探讨一种能够极大提升代码效率，特别是递归函数效率的强大技术——<strong>记忆化（Memoization）</strong>。</p>
<p>想象一下，你让计算机解决一个问题，它却像一个健忘的学徒，一遍又一遍地计算着早已知道答案的子问题。这不仅浪费了宝贵的计算资源，也让你的程序运行得像蜗牛一样慢。记忆化，就是赋予我们程序“记忆”能力的魔法。</p>
<h3 id="一、问题的根源：重复的计算"><a href="#一、问题的根源：重复的计算" class="headerlink" title="一、问题的根源：重复的计算"></a>一、问题的根源：重复的计算</h3><p>让我们从一个经典得不能再经典的例子开始：<strong>斐波那契数列（Fibonacci Sequence）</strong>。</p>
<p>它的定义很简单：</p>
<ul>
<li><code>fib(0) = 0</code></li>
<li><code>fib(1) = 1</code></li>
<li><code>fib(n) = fib(n-1) + fib(n-2)</code> (当 n &gt; 1 时)</li>
</ul>
<p>用 Python 来实现这个定义，最直观的方式就是写一个简单的递归函数：</p>
<p><strong>版本一：朴素的递归实现</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算斐波那契数列的第 n 项（朴素递归法）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让我们来测试一下</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib(5) = <span class="subst">&#123;fib(<span class="number">5</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib(10) = <span class="subst">&#123;fib(<span class="number">10</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># print(f&quot;fib(40) = &#123;fib(40)&#125;&quot;) # 尝试运行这行，你会等到天荒地老...</span></span><br></pre></td></tr></table></figure>

<p>这段代码看起来简洁优美，完美地翻译了数学定义。但它的性能如何呢？</p>
<p>让我们来追踪一下 <code>fib(5)</code> 的计算过程，你会看到一棵像这样的“调用树”：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                   <span class="function"><span class="title">fib</span>(<span class="number">5</span>)</span></span><br><span class="line">                /         \</span><br><span class="line">            <span class="function"><span class="title">fib</span>(<span class="number">4</span>)         <span class="title">fib</span>(<span class="number">3</span>)</span></span><br><span class="line">           /      \       /      \</span><br><span class="line">        <span class="function"><span class="title">fib</span>(<span class="number">3</span>)   <span class="title">fib</span>(<span class="number">2</span>)   <span class="title">fib</span>(<span class="number">2</span>)   <span class="title">fib</span>(<span class="number">1</span>)</span></span><br><span class="line">       /      \   /    \   /    \</span><br><span class="line">    <span class="function"><span class="title">fib</span>(<span class="number">2</span>) <span class="title">fib</span>(<span class="number">1</span>) <span class="title">fib</span>(<span class="number">1</span>) <span class="title">fib</span>(<span class="number">0</span>) <span class="title">fib</span>(<span class="number">1</span>) <span class="title">fib</span>(<span class="number">0</span>)</span></span><br><span class="line">   /      \</span><br><span class="line"><span class="function"><span class="title">fib</span>(<span class="number">1</span>)   <span class="title">fib</span>(<span class="number">0</span>)</span></span><br></pre></td></tr></table></figure>

<p>发现了问题所在吗？</p>
<ul>
<li><code>fib(3)</code> 被计算了 <strong>2</strong> 次。</li>
<li><code>fib(2)</code> 被计算了 <strong>3</strong> 次。</li>
<li><code>fib(1)</code> 被计算了 <strong>5</strong> 次。</li>
</ul>
<p>仅仅是计算 <code>fib(5)</code>，就有如此多的冗余。当 <code>n</code> 增长到 40 或 50，重复计算的次数将呈指数级爆炸式增长（时间复杂度为 O(2^n)），足以让现代计算机陷入漫长的等待。</p>
<p>这就是我们需要“记忆化”来拯救世界的时刻。</p>
<h3 id="二、核心思想：记住你算过的"><a href="#二、核心思想：记住你算过的" class="headerlink" title="二、核心思想：记住你算过的"></a>二、核心思想：记住你算过的</h3><p><strong>记忆化（Memoization）</strong>的核心思想异常简单：</p>
<blockquote>
<p><strong>如果一个计算你已经执行过，就把结果存起来。下次再遇到同样的计算，直接拿出存好的结果，不要再算一遍。</strong></p>
</blockquote>
<p>这本质上是一种“用空间换时间”的策略。我们开辟一小块内存空间（我们的“记忆”），用来缓存计算结果，从而避免了大量耗时的重复计算。</p>
<p>我们如何为上面的 <code>fib</code> 函数植入“记忆”呢？通常，我们会使用一个<strong>字典（dictionary）</strong>或<strong>哈希表（hash map）</strong>来作为我们的缓存（cache）。</p>
<p><strong>版本二：带有记忆化的递归实现</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个缓存字典，用来存储已经计算过的结果</span></span><br><span class="line">memo_cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_memo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算斐波那G契数列的第 n 项（带记忆化的递归）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 在计算之前，先检查“记忆”里有没有</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo_cache:</span><br><span class="line">        <span class="keyword">return</span> memo_cache[n] <span class="comment"># 如果有，直接返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 如果没有，再进行计算（和之前的逻辑一样）</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        result = n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = fib_memo(n-<span class="number">1</span>) + fib_memo(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 在返回结果之前，把这次的结果存入“记忆”</span></span><br><span class="line">    memo_cache[n] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让我们来测试一下性能的飞跃</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_memo(40) = <span class="subst">&#123;fib_memo(<span class="number">40</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_memo(50) = <span class="subst">&#123;fib_memo(<span class="number">50</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 这一次，结果几乎是瞬间出现的！</span></span><br></pre></td></tr></table></figure>

<p>让我们再次分析 <code>fib_memo(5)</code> 的调用过程：</p>
<ol>
<li><code>fib_memo(5)</code>：缓存里没有，计算 <code>fib_memo(4) + fib_memo(3)</code>。</li>
<li><code>fib_memo(4)</code>：缓存里没有，计算 <code>fib_memo(3) + fib_memo(2)</code>。</li>
<li><code>fib_memo(3)</code>：缓存里没有，计算 <code>fib_memo(2) + fib_memo(1)</code>。</li>
<li><code>fib_memo(2)</code>：缓存里没有，计算 <code>fib_memo(1) + fib_memo(0)</code>。</li>
<li><code>fib_memo(1)</code>：返回 1，并存入缓存 <code>&#123;1: 1&#125;</code>。</li>
<li><code>fib_memo(0)</code>：返回 0，并存入缓存 <code>&#123;0: 0, 1: 1&#125;</code>。</li>
<li><code>fib_memo(2)</code> 完成计算 (1+0&#x3D;1)，存入缓存 <code>&#123;0:0, 1:1, 2:1&#125;</code>。</li>
<li><code>fib_memo(3)</code> 需要 <code>fib_memo(1)</code>，<strong>直接从缓存读取</strong>，计算 (1+1&#x3D;2)，存入缓存 <code>&#123;..., 3:2&#125;</code>。</li>
<li><code>fib_memo(4)</code> 需要 <code>fib_memo(2)</code>，<strong>直接从缓存读取</strong>，计算 (2+1&#x3D;3)，存入缓存 <code>&#123;..., 4:3&#125;</code>。</li>
<li><code>fib_memo(5)</code> 需要 <code>fib_memo(3)</code>，<strong>直接从缓存读取</strong>，计算 (3+2&#x3D;5)，存入缓存 <code>&#123;..., 5:5&#125;</code>。</li>
</ol>
<p>看！<code>fib_memo(3)</code> 和 <code>fib_memo(2)</code> 现在只被完整地计算了一次。所有后续的调用都直接从缓存中获取了结果。通过这种方式，我们将时间复杂度从 O(2^n) 奇迹般地降到了 **O(n)**，因为从 0 到 n 的每个斐波那契数都只被计算了一次。</p>
<h3 id="三、更优雅的实现：Python装饰器"><a href="#三、更优雅的实现：Python装饰器" class="headerlink" title="三、更优雅的实现：Python装饰器"></a>三、更优雅的实现：Python装饰器</h3><p>虽然上面的方法很有效，但它把缓存逻辑和业务逻辑（斐波那契计算）混在了一起。如果我有很多个函数都需要记忆化，难道要给每个函数都写一套缓存逻辑吗？</p>
<p>当然不！这正是 Python 中<strong>装饰器（Decorator）</strong>大显身手的时刻。装饰器允许我们在不修改函数代码本身的情况下，为函数添加额外的功能。</p>
<p>我们可以编写一个通用的 <code>memoize</code> 装饰器。</p>
<p><strong>版本三：使用装饰器实现记忆化</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">memoize</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个通用的记忆化装饰器&quot;&quot;&quot;</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="comment"># 注意：这里我们使用 *args 作为键，使其能处理多个参数的函数</span></span><br><span class="line">        <span class="comment"># 但要确保参数是可哈希的（比如数字、字符串、元组）</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_decorator</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;应用了记忆化装饰器的斐波那契函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib_decorator(n-<span class="number">1</span>) + fib_decorator(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下，同样飞快！</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_decorator(50) = <span class="subst">&#123;fib_decorator(<span class="number">50</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib_decorator(100) = <span class="subst">&#123;fib_decorator(<span class="number">100</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>@memoize</code> 语法糖，完全等同于 <code>fib_decorator = memoize(fib_decorator)</code>。</p>
<p>这种方式的好处是：</p>
<ol>
<li><strong>代码整洁</strong>：<code>fib_decorator</code> 函数内部只关心核心的计算逻辑。</li>
<li><strong>高度复用</strong>：你可以把 <code>@memoize</code> 这个装饰器应用到任何其他需要记忆化的、符合条件的函数上。</li>
</ol>
<h3 id="四、什么时候应该使用记忆化？"><a href="#四、什么时候应该使用记忆化？" class="headerlink" title="四、什么时候应该使用记忆化？"></a>四、什么时候应该使用记忆化？</h3><p>记忆化虽好，但并非万能。它在以下场景中最为有效：</p>
<ol>
<li><strong>函数是“纯”的（Pure Function）</strong>：这是最重要的前提。纯函数意味着对于相同的输入，永远返回相同的输出，并且没有可观察的副作用（比如修改全局变量、打印日志等）。斐波那契函数就是典型的纯函数。</li>
<li><strong>存在大量重叠子问题（Overlapping Subproblems）</strong>：就像我们的斐波那契例子，递归过程中反复求解相同的子问题。如果一个问题可以被分解成子问题，但子问题之间毫无关联，那么记忆化就派不上用场。</li>
<li><strong>计算成本较高</strong>：如果一个函数本身的计算非常快，那么为它增加缓存和查找的开销可能得不偿失。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天，我们通过斐波那契数列的例子，深入了解了<strong>记忆化</strong>这一强大的性能优化技术。</p>
<ul>
<li><strong>核心痛点</strong>：递归调用中存在大量的重复计算，导致指数级的时间复杂度。</li>
<li><strong>解决方案</strong>：使用缓存（如字典）存储计算结果，避免重复劳动，实现“用空间换时间”。</li>
<li><strong>最佳实践</strong>：将记忆化逻辑封装成一个通用的装饰器，以保持业务代码的纯粹和整洁。</li>
</ul>
<p>记忆化是<strong>动态规划（Dynamic Programming）</strong>思想的重要组成部分，是每个程序员都应该掌握的基本功。希望通过这篇详细的讲解，你已经彻底理解了它的原理和应用。现在，去检查一下你的代码，看看有没有哪个“健忘”的函数正在等待你赋予它“记忆”吧！</p>
</blockquote>
<p>​		<strong>读这种文章的感觉就和读大佬写的博客文一样酣畅淋漓！</strong>然后我又让他解释了一下其中装饰器的作用，还是这种模式的回复：</p>
<blockquote>
<p>当然可以！很高兴你对这个话题有如此浓厚的兴趣。装饰器是 Python 中一个非常强大且优雅的特性，一旦你理解了它，就会发现它无处不在。</p>
<p>让我们一步一步，把“<code>@memoize</code> 等同于 <code>fib_decorator = memoize(fib_decorator)</code>”这块硬骨头彻底啃下来。</p>
<h3 id="第-1-步：理解-Python-的核心前提——函数是“一等公民”"><a href="#第-1-步：理解-Python-的核心前提——函数是“一等公民”" class="headerlink" title="第 1 步：理解 Python 的核心前提——函数是“一等公民”"></a>第 1 步：理解 Python 的核心前提——函数是“一等公民”</h3><p>在 Python 中，函数（function）和我们常见的数字（<code>123</code>）、字符串（<code>&quot;hello&quot;</code>）、列表（<code>[1, 2, 3]</code>）一样，是一种<strong>对象</strong>。这意味着你可以像对待任何其他数据一样对待它。</p>
<p>这具体体现在三个方面：</p>
<ol>
<li><p><strong>可以被赋值给一个变量</strong></p>
<p>Python</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数 say_hello 赋值给变量 greet</span></span><br><span class="line">greet = say_hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在调用 greet 和调用 say_hello 的效果完全一样</span></span><br><span class="line">greet()       <span class="comment"># 输出: Hello!</span></span><br><span class="line">say_hello()   <span class="comment"># 输出: Hello!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以作为参数传递给另一个函数</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_operation</span>(<span class="params">func, x, y</span>):</span><br><span class="line">    <span class="comment"># 调用传进来的函数 func</span></span><br><span class="line">    <span class="keyword">return</span> func(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 add 函数作为参数传进去</span></span><br><span class="line">result1 = simple_operation(add, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Result of addition: <span class="subst">&#123;result1&#125;</span>&quot;</span>) <span class="comment"># 输出: 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 subtract 函数作为参数传进去</span></span><br><span class="line">result2 = simple_operation(subtract, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Result of subtraction: <span class="subst">&#123;result2&#125;</span>&quot;</span>) <span class="comment"># 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>simple_operation</code> 就是一个<strong>高阶函数（Higher-Order Function）</strong>，因为它接受了另一个函数作为参数。</p>
</li>
<li><p><strong>可以作为另一个函数的返回值</strong></p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_greeter</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="comment"># 定义一个内部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeter</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="comment"># 返回这个内部函数</span></span><br><span class="line">    <span class="keyword">return</span> greeter</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 调用 get_greeter，它返回了 greeter 函数</span></span><br><span class="line">greet_bob = get_greeter(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">greet_alice = get_greeter(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># greet_bob 现在是一个函数了！</span></span><br><span class="line">greet_bob()   <span class="comment"># 输出: Hello, Bob!</span></span><br><span class="line">greet_alice() <span class="comment"># 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>理解了“函数是一等公民”这个核心概念，我们就为理解装饰器铺平了道路。</p>
<h3 id="第-2-步：手动实现一个装饰器"><a href="#第-2-步：手动实现一个装饰器" class="headerlink" title="第 2 步：手动实现一个装饰器"></a>第 2 步：手动实现一个装饰器</h3><p>装饰器本质上就是一个高阶函数，它<strong>接收一个函数作为输入，并返回一个新的函数作为输出</strong>。这个新的函数通常会在执行原始函数的前后，添加一些额外的功能。</p>
<p>让我们来手动实现这个过程，不使用 <code>@</code> 语法。</p>
<p>假设我们有一个简单的函数：</p>
<p>Python</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">ordinary_function</span>():</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="string">&quot;正在执行核心业务...&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>现在，我们想在不修改 <code>ordinary_function</code> 源码的情况下，在它执行前后打印日志。我们可以写一个“装饰函数”：</p>
<p>Python</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def logging_decorator(original_func):</span><br><span class="line">    # original_func 就是我们想装饰的函数，比如 ordinary_function</span><br><span class="line"></span><br><span class="line">    # <span class="number">1.</span> 定义一个新的“包装”函数</span><br><span class="line">    def <span class="keyword">wrapper</span>():</span><br><span class="line">        print(f&quot;【日志】函数 &#x27;&#123;original_func.__name__&#125;&#x27; 即将执行...&quot;)</span><br><span class="line">        </span><br><span class="line">        # <span class="number">2.</span> 在包装函数内部，调用原始函数</span><br><span class="line">        original_func()</span><br><span class="line">        </span><br><span class="line">        print(f&quot;【日志】函数 &#x27;&#123;original_func.__name__&#125;&#x27; 执行完毕。&quot;)</span><br><span class="line"></span><br><span class="line">    # <span class="number">3.</span> 返回这个包装好的新函数</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">wrapper</span></span><br></pre></td></tr></table></figure>

<p>现在，最关键的一步来了。我们如何使用 <code>logging_decorator</code> 来“装饰” <code>ordinary_function</code> 呢？</p>
<p>Python</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将我们的普通函数“喂”给装饰器，然后用返回的新函数，覆盖掉原来的函数名</span><br><span class="line">ordinary_function = logging_decorator(ordinary_function)</span><br><span class="line"></span><br><span class="line"># 现在，当你调用 ordinary_function 时，你实际上调用的是 <span class="keyword">wrapper</span> 函数！</span><br><span class="line">ordinary_function()</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【日志】函数 <span class="string">&#x27;ordinary_function&#x27;</span> 即将执行<span class="params">...</span></span><br><span class="line">正在执行核心业务<span class="params">...</span></span><br><span class="line">【日志】函数 <span class="string">&#x27;ordinary_function&#x27;</span> 执行完毕。</span><br></pre></td></tr></table></figure>

<p>看到了吗？<code>ordinary_function = logging_decorator(ordinary_function)</code> 这行代码，就是装饰器模式的核心。它用一个功能更强的“包装版”函数，替换了原始的函数。</p>
<h3 id="第-3-步：揭开-的神秘面纱"><a href="#第-3-步：揭开-的神秘面纱" class="headerlink" title="第 3 步：揭开 @ 的神秘面纱"></a>第 3 步：揭开 <code>@</code> 的神秘面纱</h3><p>Python 的设计者们发现，上面这种 <code>func = decorator(func)</code> 的写法非常常用，所以他们创造了一个更简洁、更具可读性的语法来做<strong>完全相同</strong>的事情，这个语法就是 <code>@</code>，我们称之为“语法糖（Syntactic Sugar）”。</p>
<p>所以，下面这两段代码是<strong>完全等价的</strong>：</p>
<p><strong>写法一：手动赋值</strong></p>
<p>Python</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="function"><span class="title">ordinary_function</span>():</span></span><br><span class="line"><span class="function">    <span class="title">print</span>(<span class="string">&quot;正在执行核心业务...&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">ordinary_function</span> = <span class="function"><span class="title">logging_decorator</span>(<span class="variable">ordinary_function</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>写法二：使用 <code>@</code> 语法糖</strong></p>
<p>Python</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@logging_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ordinary_function</span>():</span><br><span class="line">    print(<span class="string">&quot;正在执行核心业务...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当 Python 解释器读到 <code>@logging_decorator</code> 时，它会先定义 <code>ordinary_function</code>，然后<strong>自动地</strong>在内部执行 <code>ordinary_function = logging_decorator(ordinary_function)</code> 这个操作。</p>
<h3 id="第-4-步：回到-memoize"><a href="#第-4-步：回到-memoize" class="headerlink" title="第 4 步：回到 @memoize"></a>第 4 步：回到 <code>@memoize</code></h3><p>现在，我们带着全新的理解，回头看 <code>memoize</code> 的例子：</p>
<p>Python</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">memoize</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function">    cache</span> = &#123;&#125;</span><br><span class="line">    <span class="function">def <span class="title">wrapper</span>(<span class="params">*<span class="keyword">args</span></span>):</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="keyword">args</span> <span class="keyword">not</span> <span class="keyword">in</span> cache:</span></span><br><span class="line"><span class="function">            cache[<span class="keyword">args</span>]</span> = func(*<span class="keyword">args</span>) <span class="meta"># 这里调用的是原始的 fib_decorator</span></span><br><span class="line">        <span class="keyword">return</span> cache[<span class="keyword">args</span>]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">@memoize</span><br><span class="line"><span class="function">def <span class="title">fib_decorator</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> n &lt;</span>= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="function">n</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">fib_decorator</span>(<span class="params">n<span class="number">-1</span></span>) + <span class="title">fib_decorator</span>(<span class="params">n<span class="number">-2</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>这段代码在 Python 解释器眼里的执行流程是：</p>
<ol>
<li>解释器看到了 <code>def fib_decorator...</code>，于是它在内存中创建了一个斐波那契计算函数，我们称之为**原始 <code>fib_decorator</code>**。</li>
<li>接着，解释器看到了它头顶的 <code>@memoize</code>。</li>
<li>它立刻执行 <code>memoize(原始_fib_decorator)</code>。</li>
<li><code>memoize</code> 函数返回了 <code>wrapper</code> 函数。（这个 <code>wrapper</code> 函数内部通过闭包 <code>func</code> 记住了**原始 <code>fib_decorator</code>**，并且还创建了一个私有的 <code>cache</code> 字典）。</li>
<li>解释器用返回的 <code>wrapper</code> 函数，覆盖了 <code>fib_decorator</code> 这个名字。</li>
</ol>
<p>所以，在这之后，当你的代码调用 fib_decorator(5) 时，你实际上调用的是 wrapper(5)。</p>
<p>wrapper 函数会：</p>
<ul>
<li>检查 <code>(5,)</code> 这个参数元组是否在它的 <code>cache</code> 里。</li>
<li>如果不在，它就会调用它所“记住”的<strong>原始 <code>fib_decorator</code></strong> 函数（<code>func(5)</code>），并将计算结果存入 <code>cache</code>。</li>
<li>最后，返回 <code>cache</code> 中的值。</li>
</ul>
<p>有趣的是，<code>wrapper</code> 内部的递归调用 <code>fib_decorator(n-1)</code> 和 <code>fib_decorator(n-2)</code>，因为 <code>fib_decorator</code> 这个名字已经被替换了，所以它们调用的也是 <code>wrapper</code> 函数，而不是原始函数。这恰好就是我们想要的——确保每一次递归调用都能利用上缓存机制！</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>@decorator</code> 就是一个语法糖，它让你能够以一种声明式的方式，将一个函数（<code>decorator</code>）应用到另一个函数（被装饰的函数）上。</p>
<p>其背后的完整逻辑链是：</p>
<p>@decorator -&gt; func &#x3D; decorator(func) -&gt; 函数作为一等公民（可以被传递和返回）</p>
<p>希望这个从底层原理到语法糖的逐层剖析，能让你彻底明白装饰器的运作方式！</p>
</blockquote>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">关于我用gemini的一些心得体会</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8Gemini%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">用Gemini进行文档总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2z%E6%96%87%E7%AB%A0%EF%BC%9A%E7%94%A8%E2%80%9C%E8%AE%B0%E5%BF%86%E2%80%9D%E7%BB%99%E4%BB%A3%E7%A0%81%E5%8A%A0%E9%80%9F%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E2%80%9C%E8%AE%B0%E5%BF%86%E5%8C%96%EF%BC%88Memoization%EF%BC%89%E2%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">博客z文章：用“记忆”给代码加速——深入解析“记忆化（Memoization）”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E9%87%8D%E5%A4%8D%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、问题的根源：重复的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E8%AE%B0%E4%BD%8F%E4%BD%A0%E7%AE%97%E8%BF%87%E7%9A%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、核心思想：记住你算过的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">三、更优雅的实现：Python装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">四、什么时候应该使用记忆化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E6%AD%A5%EF%BC%9A%E7%90%86%E8%A7%A3-Python-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%89%8D%E6%8F%90%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D"><span class="toc-number">1.2.6.</span> <span class="toc-text">第 1 步：理解 Python 的核心前提——函数是“一等公民”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E6%AD%A5%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">第 2 步：手动实现一个装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E6%AD%A5%EF%BC%9A%E6%8F%AD%E5%BC%80-%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="toc-number">1.2.8.</span> <span class="toc-text">第 3 步：揭开 @ 的神秘面纱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E6%AD%A5%EF%BC%9A%E5%9B%9E%E5%88%B0-memoize"><span class="toc-number">1.2.9.</span> <span class="toc-text">第 4 步：回到 @memoize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.2.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&text=关于我用gemini的一些心得体会"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&is_video=false&description=关于我用gemini的一些心得体会"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于我用gemini的一些心得体会&body=Check out this article: http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&title=关于我用gemini的一些心得体会"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&name=关于我用gemini的一些心得体会&description=&lt;h1 id=&#34;关于我用gemini的一些心得体会&#34;&gt;&lt;a href=&#34;#关于我用gemini的一些心得体会&#34; class=&#34;headerlink&#34; title=&#34;关于我用gemini的一些心得体会&#34;&gt;&lt;/a&gt;关于我用gemini的一些心得体会&lt;/h1&gt;&lt;p&gt;​		最近刚刚白嫖了Gemini的15个月学生会员，于是开始用这个号称目前top1的大模型，并且在使用过程中，有了一些自己的使用心得。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yatq.xyz/%E6%9D%82%E8%B0%88/%E5%85%B3%E4%BA%8E%E6%88%91%E7%94%A8gemini%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/&t=关于我用gemini的一些心得体会"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    y@7q
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
